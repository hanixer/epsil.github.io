<!DOCTYPE html>
<html lang="no">
<head>
<title>Closures i Lisp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="text/css" http-equiv="Content-Style-Type">
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="../../../favicon.ico" rel="icon" type="image/x-icon">
<link href="../../../css/markdown-template.css" rel="stylesheet">
<link href="index.txt" rel="alternate" title="Markdown" type="text/markdown">
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script src="../../../js/markdown-template.js">
</script>
</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top">
<div class="container-fluid">
<ul class="nav nav-pills navbar-left">
<li role="presentation"><a href="/" title="Return home"><i class="fa fa-home"></i></a>
</li>
</ul>

<ul class="nav nav-pills navbar-right">
<li role="presentation"><a href="http://www.facebook.com/share.php?u=about%3Ablank" title="Share on Facebook"><i class="fa fa-facebook-square"></i></a>
</li>

<li role="presentation"><a href="https://twitter.com/intent/tweet?url=about%3Ablank" title="Share on Twitter"><i class="fa fa-twitter-square"></i></a>
</li>

<li role="presentation"><a href="mailto:?body=about%3Ablank" title="Share by mail"><i class="fa fa-envelope"></i></a>
</li>

<li role="presentation"><a href="https://github.com/epsil/epsil.github.io/tree/master/blank/index.txt" title="Edit on GitHub"><i class="fa fa-edit"></i></a>
</li>

<li role="presentation"><a href="index.txt" title="Get Markdown source"><i class="fa fa-download"></i></a>
</li>

<li role="presentation"><a data-toggle="collapse" href="#toc" title="Table of contents"><i class="fa fa-bars"></i></a>
</li>
</ul>
</div>

<div class="collapse" id="toc" title="Innhold">
</div>
</nav>

<div class="container">
<article>
<header>
<h1 class="title">Closures i Lisp</h1>

<p><time><i class="fa fa-calendar-o"></i> 2011-10-07</time>
</p>
</header>

<section id="content">
<blockquote>
<p>In the remotest regions, beyond the Functional Kingdoms, lies a fabled realm called Lambda the Ultimate. In this place it is said that there are no nouns at all, only verbs! There are “things” there, but all things are created from verbs, even the very integers for counting lambs, which are the most popular form of trading currency there, if the rumors speak truth. The number zero is simply <code>lambda()</code>, and 1 is <code>lambda(lambda())</code>, 2 is <code>lambda(lambda(lambda()))</code>, and so on. Every single Thing in this legendary region, be it noun, verb or otherwise, is constructed from the primal verb “lambda”.</p>

<footer>Steve Yegge: <cite>Execution in the Kingdom of Nouns</cite><sup class="footnote-ref"><a href="#fn1" id="fnref1" title="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">[1]</a></sup></footer>
</blockquote>

<p>Det er i prinsippet mulig å bruke lambdaer som et fundament for videre programmering. Det klassiske <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html"><em><abbr class="acronym" title="Structure and Interpretation of Computer Programs">SICP</abbr></em></a>-eksemplet er å definere <code>cons</code>, <code>car</code> og <code>cdr</code> på denne måten,<sup class="footnote-ref"><a href="#fn2" id="fnref2" title="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.3">[2]</a></sup> som vi kan tenke på som Lisp-sjargong for <code>pair</code>, <code>first</code> og <code>second</code>. La <code>pair</code> være en funksjon som returnerer et par med verdier, <code>first</code> returnere den første verdien til paret, og <code>second</code> returnere den andre:</p>

<pre><code class="language-scheme">&gt; (pair "foo" "bar")
#&lt;par av "foo" og "bar"&gt;

&gt; (first (pair "foo" "bar"))
"foo"

&gt; (second (pair "foo" "bar"))
"bar"
</code></pre>

<p>Den vanlige måten å implementere dette på ville være å konstruere en listestruktur – et stykke data – med <code>pair</code>, og så la <code>first</code> og <code>second</code> hente ut riktig element fra strukturen. <em><abbr class="acronym" title="Structure and Interpretation of Computer Programs">SICP</abbr></em> sin fremgangsmåte er derimot å implementere paret som en <em>prosedyre</em>:</p>

<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">pair</span> x y)
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (m)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
     ((<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> m <span class="hljs-number">1</span>) x)
     ((<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> m <span class="hljs-number">2</span>) y))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">first</span> z)
  (<span class="hljs-name">z</span> <span class="hljs-number">1</span>))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">second</span> z)
  (<span class="hljs-name">z</span> <span class="hljs-number">2</span>))
</code></pre>

<p>Her returnerer <code>pair</code> en anonym funksjon (som lages med <code>lambda</code> i Lisp). Denne funksjonen inneholder argumentene til <code>pair</code>:</p>

<pre><code class="language-scheme">&gt; (pair "foo" "bar")
#&lt;prosedyre som inneholder "foo" og "bar"&gt;
</code></pre>

<p>Det <code>first</code> og <code>second</code> så gjør, er å kalle prosedyren med et bestemt argument slik at den første eller andre verdien returneres. Dermed vil <code>(first (pair "foo" "bar"))</code> fortsatt gi <code>"foo"</code>, og <code>(second (pair "foo" "bar"))</code> gi <code>"bar"</code>. På papiret en helt adekvat implementasjon.</p>
<!--
Se [GeirGrusoms innlegg](http://www.diskusjon.no/index.php?showtopic=800754&p=18412466&st=1420&#entry18412466) over.
-->

<p>Koden over forutsetter <em>closures</em>, <abbr title="det vil si">dvs.</abbr> at prosedyren som <code>pair</code> returnerer, er i stand til å «stikke av med» argumentene til <code>pair</code>.<sup class="footnote-ref"><a href="#fn3" id="fnref3" title="Hvis Lisp’en din mangler dette, kan du alltids «jukse» ved å konstruere lambdaen som en liste og splice inn verdiene av x og y. Dette forutsetter naturligvis at x og y er immutable.">[3]</a></sup> Dermed kan man for så vidt tenke på prosedyren som et «objekt», <abbr title="det vil si">dvs.</abbr> en bunt med data og instruksjoner. (I enkelte språk, som JavaScript og Scala, <em>er</em> funksjoner objekter.)</p>

<p>Denne litt alternative måten å konstruere «objekter» på – å lage anomyme funksjoner som lukker om bindingene i et leksikalsk skop – er faktisk mye brukt i funksjonelle språk. Google «<a href="http://www.google.no/search?q=let+over+lambda">let over lambda</a>» når du har tid.</p>

<hr class="footnotes-sep">

<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="fn1">
<p><a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html</a> <a class="footnote-backref" href="#fnref1" title="Steve Yegge: Execution in the Kingdom of Nouns[1]">↩︎</a></p>
</li>

<li class="footnote-item" id="fn2">
<p><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%25_sec_2.1.3">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.3</a> <a class="footnote-backref" href="#fnref2" title="Det er i prinsippet mulig å bruke lambdaer som et fundament for videre programmering. Det klassiske SICP-eksemplet er å definere cons, car og cdr på denne måten,[2] som vi kan tenke på som Lisp-sjargong for pair, first og second. La pair være en funksjon som returnerer et par med verdier, first returnere den første verdien til paret, og second returnere den andre:">↩︎</a></p>
</li>

<li class="footnote-item" id="fn3">
<p>Hvis Lisp’en din mangler dette, kan du alltids «jukse» ved å konstruere lambdaen som en liste og splice inn verdiene av <code>x</code> og <code>y</code>. Dette forutsetter naturligvis at <code>x</code> og <code>y</code> er immutable. <a class="footnote-backref" href="#fnref3" title="Koden over forutsetter closures, dvs. at prosedyren som pair returnerer, er i stand til å «stikke av med» argumentene til pair.[3] Dermed kan man for så vidt tenke på prosedyren som et «objekt», dvs. en bunt med data og instruksjoner. (I enkelte språk, som JavaScript og Scala, er funksjoner objekter.)">↩︎</a></p>
</li>
</ol>
</section>
</section>
</article>
</div>
</body>
</html>
